<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>PDF with Editable Annotations → Export via pdf-lib (vector)</title>
    <style>
      body {
        font-family: system-ui, -apple-system, "Segoe UI", Roboto,
          "Helvetica Neue", Arial;
        margin: 12px;
      }
      #controls {
        margin-bottom: 8px;
      }
      #container {
        position: relative;
        max-width: 1000px;
        margin: 10px auto;
        border: 1px solid #ccc;
        padding: 10px;
        background: #f8f8f8;
      }
      .page-container {
        position: relative;
        margin-bottom: 28px;
      }
      canvas {
        display: block;
        border: 1px solid #999;
        max-width: 100%;
      }
      .annotation-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      .annotation {
        position: absolute;
        background: rgba(255, 255, 4, 0.95);
        border: 1px dashed #c1c1c1;
        padding: 6px;
        cursor: move;
        pointer-events: auto;
        user-select: text;
        min-width: 140px;
        min-height: 50px;
        resize: both;
        overflow: auto;
        font-size: 13px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
      }
      .annotation-header {
        display: flex;
        gap: 6px;
        align-items: center;
        margin-bottom: 6px;
        font-size: 12px;
        color: #333;
      }
      .annotation-header input {
        font-size: 12px;
        padding: 2px 4px;
      }
      .annotation-content {
        min-height: 40px;
        outline: none;
        font-size: 13px;
      }
      .reply-box {
        display: none;
        margin-top: 6px;
      }
      .reply-box textarea {
        width: 98%;
        height: 46px;
        resize: vertical;
      }
      .annotation button {
        margin-top: 6px;
        padding: 4px 6px;
        font-size: 12px;
      }
      #pageRange {
        width: 120px;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <input type="file" id="fileInput" accept="application/pdf" />
      <button id="btnLoad">Load PDF</button>
      <button id="btnAddAnnotation">Add Annotation</button>
      <input id="pageRange" placeholder="e.g. 1 or 2-4" />
      <button id="btnExtract">Extract Pages (pdfs)</button>
      <button id="btnExport">Export PDF (pdf-lib, vector)</button>
      <span style="margin-left: 12px; color: #555; font-size: 13px">
        Tip: after adding annotations, hit Export. Export keeps original crisp
        text.
      </span>
    </div>

    <div id="container"></div>

    <!-- pdf.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <!-- pdf-lib -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <!-- html2canvas only used for Extract pages (optional) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- jsPDF used only for extract pages -> image PDF (optional) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

    <script>
      // Globals
      const container = document.getElementById("container");
      const fileInput = document.getElementById("fileInput");
      const btnLoad = document.getElementById("btnLoad");
      const btnAddAnnotation = document.getElementById("btnAddAnnotation");
      const btnExport = document.getElementById("btnExport");
      const btnExtract = document.getElementById("btnExtract");
      const pageRangeInput = document.getElementById("pageRange");

      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";

      let pdfDoc = null;
      let currentScale = 1.5; // rendering scale for on-screen preview
      let pages = []; // will store { pageContainer, canvas, annotationLayer, viewport }
      let originalArrayBuffer = null; // bytes of loaded pdf file

      // Load PDF from <input>
      btnLoad.addEventListener("click", async () => {
        if (!fileInput.files || !fileInput.files[0]) {
          alert("Select a PDF file first");
          return;
        }
        const file = fileInput.files[0];
        originalArrayBuffer = await file.arrayBuffer();
        await renderPDF(originalArrayBuffer);
      });

      async function extractPages(arrayBuffer, pageNumbers /* e.g. [1,3,4] */) {
        const { PDFDocument } = PDFLib;

        // Load original PDF
        const srcDoc = await PDFDocument.load(arrayBuffer);

        // Create new PDF
        const newDoc = await PDFDocument.create();

        // Copy specified pages (pdf-lib is 0-indexed)
        const pagesToCopy = await newDoc.copyPages(
          srcDoc,
          pageNumbers.map((n) => n - 1)
        );
        pagesToCopy.forEach((p) => newDoc.addPage(p));

        // Save
        const newPdfBytes = await newDoc.save();
        const blob = new Blob([newPdfBytes], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "extracted-pages.pdf";
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 5000);
      }

      async function renderPDF(arrayBuffer) {
        container.innerHTML = "";
        pages = [];
        pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

        for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
          const page = await pdfDoc.getPage(pageNum);
          const viewport = page.getViewport({ scale: currentScale });

          const pageContainer = document.createElement("div");
          pageContainer.className = "page-container";
          pageContainer.style.width = viewport.width + "px";
          pageContainer.style.height = viewport.height + "px";
          pageContainer.style.position = "relative";

          const canvas = document.createElement("canvas");
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          canvas.style.display = "block";
          pageContainer.appendChild(canvas);

          // annotation overlay
          const annotationLayer = document.createElement("div");
          annotationLayer.className = "annotation-layer";
          annotationLayer.style.width = viewport.width + "px";
          annotationLayer.style.height = viewport.height + "px";
          pageContainer.appendChild(annotationLayer);

          container.appendChild(pageContainer);

          const ctx = canvas.getContext("2d");
          await page.render({ canvasContext: ctx, viewport }).promise;

          pages.push({ pageContainer, canvas, annotationLayer, viewport });
        }
      }

      // Add annotation button — creates an annotation on the first page by default
      btnAddAnnotation.addEventListener("click", () => {
        if (pages.length === 0) {
          alert("Load a PDF first!");
          return;
        }
        const pageIndex = 0; // default to first page — you can expand to ask for page selection
        createAnnotationAt(pages[pageIndex].annotationLayer, 20, 20);
      });

      // Create annotation helper
      function createAnnotationAt(
        annotationLayer,
        leftPx,
        topPx,
        existingData
      ) {
        const annotation = document.createElement("div");
        annotation.className = "annotation";
        annotation.style.left = (leftPx || 20) + "px";
        annotation.style.top = (topPx || 20) + "px";
        annotation.style.width = "220px";
        annotation.style.height = "110px";

        // header: name input + created label
        const header = document.createElement("div");
        header.className = "annotation-header";

        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.placeholder = "Author";
        nameInput.value = (existingData && existingData.author) || "";

        const createdSpan = document.createElement("span");
        const now =
          existingData && existingData.createdStr
            ? existingData.createdStr
            : new Date().toLocaleString();
        createdSpan.textContent = "Created: " + now;

        // store dataset for export (ISO format)
        annotation.dataset.created =
          (existingData && existingData.createdISO) || new Date().toISOString();

        header.appendChild(nameInput);
        header.appendChild(createdSpan);

        // main editable content
        const content = document.createElement("div");
        content.className = "annotation-content";
        content.contentEditable = true;
        content.textContent =
          (existingData && existingData.text) || "Write your note...";

        // reply UI
        const replyBtn = document.createElement("button");
        replyBtn.type = "button";
        replyBtn.textContent = "Reply";

        const replyBox = document.createElement("div");
        replyBox.className = "reply-box";
        replyBox.innerHTML = `
          <textarea placeholder="Write a reply..."></textarea><br>
          <button class="send-reply" type="button">Send</button>
        `;

        replyBtn.addEventListener("click", () => {
          replyBox.style.display =
            replyBox.style.display === "none" ? "block" : "none";
        });

        replyBox.querySelector(".send-reply").addEventListener("click", () => {
          const txt = replyBox.querySelector("textarea").value.trim();
          if (txt) {
            const p = document.createElement("p");
            p.textContent =
              (nameInput.value ? nameInput.value + " replied: " : "Reply: ") +
              txt;
            annotation.appendChild(p);
            replyBox.querySelector("textarea").value = "";
            replyBox.style.display = "none";
          }
        });

        annotation.appendChild(header);
        annotation.appendChild(content);
        annotation.appendChild(replyBtn);
        annotation.appendChild(replyBox);

        annotationLayer.appendChild(annotation);
        makeDraggable(annotation);
        // focus first input
        nameInput.focus();

        return annotation;
      }

      // Export using pdf-lib — draws text on original PDF pages (vector)
      btnExport.addEventListener("click", async () => {
        if (!originalArrayBuffer) {
          alert("Load a PDF first");
          return;
        }
        // Collect annotations from DOM
        const annotations = []; // { pageIndex, leftPx, topPx, widthPx, heightPx, author, createdISO, createdStr, text }
        pages.forEach((p, pageIndex) => {
          const layer = p.annotationLayer;
          layer.querySelectorAll(".annotation").forEach((el) => {
            const leftPx = parseFloat(el.style.left) || 0;
            const topPx = parseFloat(el.style.top) || 0;
            const widthPx =
              parseFloat(el.style.width) || el.getBoundingClientRect().width;
            const heightPx =
              parseFloat(el.style.height) || el.getBoundingClientRect().height;
            const author =
              el.querySelector(".annotation-header input")?.value || "Unknown";
            const createdISO = el.dataset.created || new Date().toISOString();
            const createdStr =
              el
                .querySelector(".annotation-header span")
                ?.textContent.replace(/^Created:\s*/, "") ||
              new Date(createdISO).toLocaleString();
            const text =
              el.querySelector(".annotation-content")?.innerText || "";

            annotations.push({
              pageIndex,
              leftPx,
              topPx,
              widthPx,
              heightPx,
              author,
              createdISO,
              createdStr,
              text,
            });
          });
        });

        if (annotations.length === 0) {
          if (!confirm("No annotations found. Export original PDF unchanged?"))
            return;
        }

        await exportWithPdfLib(originalArrayBuffer, annotations);
      });

      // Export function using pdf-lib
      async function exportWithPdfLib(arrayBuffer, annotations) {
        const { PDFDocument, rgb, StandardFonts } = PDFLib;
        const pdfDoc = await PDFDocument.load(arrayBuffer);

        // Embed Helvetica for readable text
        const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);

        // For coordinate conversion: we rendered preview pages with currentScale.
        // screen px -> PDF points: divide by currentScale.
        const scale = currentScale;

        // Draw annotations
        for (const ann of annotations) {
          const page = pdfDoc.getPages()[ann.pageIndex];
          const pageWidth = page.getWidth();
          const pageHeight = page.getHeight();

          // Convert left/top px (DOM) to PDF coordinate system (origin bottom-left)
          const xPdf = ann.leftPx / scale;
          // DOM top is distance from top; convert to bottom-left origin
          const yPdf =
            (pages[ann.pageIndex].viewport.height - ann.topPx) / scale;

          // Optionally draw a subtle rectangle background for visibility
          const rectWidthPdf = ann.widthPx / scale;
          const rectHeightPdf = ann.heightPx / scale;

          // Draw background rectangle (slightly translucent)
          page.drawRectangle({
            x: xPdf - 2,
            y: yPdf - rectHeightPdf + 2,
            width: rectWidthPdf + 4,
            height: rectHeightPdf + 6,
            color: rgb(1, 1, 0.8),
            opacity: 0.5,
            borderColor: rgb(0.6, 0.6, 0.4),
            borderWidth: 0.5,
          });

          // Author + created line
          const metaLine = `${ann.author} • ${new Date(
            ann.createdISO
          ).toLocaleString()}`;
          page.drawText(metaLine, {
            x: xPdf + 4,
            y: yPdf - 4,
            size: 9,
            font: helveticaFont,
            color: rgb(0.15, 0.15, 0.15),
            maxWidth: rectWidthPdf - 8,
          });

          // Main annotation text (wrap manually — pdf-lib doesn't auto-wrap)
          // We'll implement a simple wrapping by splitting into words and building lines.
          const text = ann.text || "";
          const maxWidth = rectWidthPdf - 8;
          const fontSize = 11;
          const words = text.split(/\s+/);
          let line = "";
          let cursorY = yPdf - 18; // below meta line
          for (let i = 0; i < words.length; i++) {
            const testLine = line ? line + " " + words[i] : words[i];
            const testWidth = helveticaFont.widthOfTextAtSize(
              testLine,
              fontSize
            );
            if (testWidth > maxWidth && line) {
              // draw current line
              page.drawText(line, {
                x: xPdf + 4,
                y: cursorY,
                size: fontSize,
                font: helveticaFont,
                color: rgb(0, 0, 0),
              });
              line = words[i];
              cursorY -= fontSize + 2;
            } else {
              line = testLine;
            }
          }
          // draw remaining
          if (line) {
            page.drawText(line, {
              x: xPdf + 4,
              y: cursorY,
              size: fontSize,
              font: helveticaFont,
              color: rgb(0, 0, 0),
            });
          }
        }

        // Save PDF and trigger download
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "annotated.pdf";
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 5000);
      }

      async function extractPages(arrayBuffer, pageNumbers /* e.g. [1,3,4] */) {
        const { PDFDocument } = PDFLib;

        // Load original PDF
        const srcDoc = await PDFDocument.load(arrayBuffer);

        // Create new PDF
        const newDoc = await PDFDocument.create();

        // Copy specified pages (pdf-lib is 0-indexed)
        const pagesToCopy = await newDoc.copyPages(
          srcDoc,
          pageNumbers.map((n) => n - 1)
        );
        pagesToCopy.forEach((p) => newDoc.addPage(p));

        // Save
        const newPdfBytes = await newDoc.save();
        const blob = new Blob([newPdfBytes], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "extracted-pages.pdf";
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 5000);
      }

      // Optional: Extract pages as images (keeps annotations visually) — uses html2canvas + jsPDF
      // btnExtract.addEventListener("click", async () => {
      //   if (pages.length === 0) {
      //     alert("Load a PDF first");
      //     return;
      //   }
      //   const { jsPDF } = window.jspdf;
      //   const pdf = new jsPDF({
      //     unit: "px",
      //     format: [pages[0].viewport.width, pages[0].viewport.height],
      //   });

      //   // support page range input "1" or "2-4"
      //   let selectedPages = [];
      //   const val = pageRangeInput.value.trim();
      //   if (!val) {
      //     for (let i = 1; i <= pages.length; i++) selectedPages.push(i);
      //   } else if (val.includes("-")) {
      //     const [s, e] = val.split("-").map((n) => parseInt(n, 10));
      //     for (let i = Math.max(1, s); i <= Math.min(pages.length, e); i++)
      //       selectedPages.push(i);
      //   } else {
      //     const n = parseInt(val, 10);
      //     if (!isNaN(n) && n >= 1 && n <= pages.length) selectedPages.push(n);
      //   }

      //   for (let i = 0; i < selectedPages.length; i++) {
      //     const idx = selectedPages[i] - 1;
      //     const page = pages[idx];
      //     const canvasCaptured = await html2canvas(page.pageContainer, {
      //       scale: 2,
      //       useCORS: true,
      //       backgroundColor: "#fff",
      //     });
      //     const imgData = canvasCaptured.toDataURL("image/png");
      //     if (i > 0) pdf.addPage([page.viewport.width, page.viewport.height]);
      //     pdf.addImage(
      //       imgData,
      //       "PNG",
      //       0,
      //       0,
      //       page.viewport.width,
      //       page.viewport.height
      //     );
      //   }
      //   pdf.save("extracted-pages.pdf");
      // });
      btnExtract.addEventListener("click", async () => {
        if (!originalArrayBuffer) {
          alert("Load a PDF first");
          return;
        }

        // parse user input page range e.g. "1-3"
        let selectedPages = [];
        const val = pageRangeInput.value.trim();
        if (!val) {
          for (let i = 1; i <= pages.length; i++) selectedPages.push(i);
        } else if (val.includes("-")) {
          const [s, e] = val.split("-").map((n) => parseInt(n, 10));
          for (let i = Math.max(1, s); i <= Math.min(pages.length, e); i++)
            selectedPages.push(i);
        } else {
          const n = parseInt(val, 10);
          if (!isNaN(n) && n >= 1 && n <= pages.length) selectedPages.push(n);
        }

        // call extractPages from above
        await extractPages(originalArrayBuffer, selectedPages);
      });

      // make draggable and ignore native resize corner
      function makeDraggable(el) {
        let isDragging = false,
          startX,
          startY,
          startLeft,
          startTop;
        el.addEventListener("mousedown", (e) => {
          // if in bottom-right corner (native resize) ignore dragging
          const rect = el.getBoundingClientRect();
          const corner = 16;
          const inResize =
            e.clientX > rect.right - corner && e.clientY > rect.bottom - corner;
          if (inResize) return; // allow native resize
          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          startLeft = parseFloat(el.style.left) || 0;
          startTop = parseFloat(el.style.top) || 0;
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onUp);
        });
        function onMove(e) {
          if (!isDragging) return;
          el.style.left = startLeft + (e.clientX - startX) + "px";
          el.style.top = startTop + (e.clientY - startY) + "px";
        }
        function onUp() {
          isDragging = false;
          document.removeEventListener("mousemove", onMove);
          document.removeEventListener("mouseup", onUp);
        }
      }

      // BONUS: allow clicking on a page to add annotation (toggle via holding Shift while clicking)
      container.addEventListener("click", (ev) => {
        if (!ev.shiftKey) return; // hold shift and click to add at position
        // find page container clicked
        for (let i = 0; i < pages.length; i++) {
          const p = pages[i];
          const rect = p.pageContainer.getBoundingClientRect();
          if (
            ev.clientX >= rect.left &&
            ev.clientX <= rect.right &&
            ev.clientY >= rect.top &&
            ev.clientY <= rect.bottom
          ) {
            const x = ev.clientX - rect.left;
            const y = ev.clientY - rect.top;
            createAnnotationAt(p.annotationLayer, x, y);
            break;
          }
        }
      });
    </script>
  </body>
</html>
